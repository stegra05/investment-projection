# API Specification (Summary)

This document outlines the key API endpoints for the Investment Planning Projection website, facilitating communication between the React frontend and the Flask backend.

**Base Path:** `/api/v1/`
**(All API paths in this document are relative to this base path)**

**Authentication Mechanism:**
Most endpoints (excluding public ones like registration/login) require authentication using **JWT (JSON Web Tokens)**.
- The `access_token` **MUST** be sent in the `Authorization` header as a Bearer token (e.g., `Authorization: Bearer <your_access_token>`).
- The `refresh_token` for the `/auth/refresh` endpoint is handled via secure, HttpOnly cookies.
Unauthenticated requests to protected endpoints **MUST** return a `401 Unauthorized` status.

**Data Types & Field Conventions:**
- **Data Types:** This specification will endeavor to clearly define data types for all request and response fields (e.g., `string`, `integer`, `number` (often a decimal represented as a `string` for precision), `boolean`, `date` (formatted as "YYYY-MM-DD" `string`), `datetime` (formatted as "YYYY-MM-DDTHH:MM:SSZ" `string` - ISO 8601), `enum` (with specific allowed `string` values listed)).
- **Required vs. Optional Fields:** For all request body schemas, each field will be explicitly marked as "required" or "optional."
- **Enum Values:** For fields representing enumerations (e.g., `asset_type`, `change_type`, recurrence fields), the valid `string` values the API expects or returns will be listed. These are defined in `backend/app/enums.py`.

**Standard Error Response Structure:**

The backend provides consistent JSON error responses. The exact structure depends on the type of error:

1.  **Errors from Pydantic Schema Validation (via `@handle_api_errors` decorator):**
    *   Typically returns a `400 Bad Request` or `422 Unprocessable Entity`.
    *   The response body includes detailed validation errors:
        ```json
        {
          "message": "Input validation failed", // Or a more specific message
          "errors": [ // A list of validation error objects from Pydantic
            {
              "loc": ["field_name", "nested_field_name_if_any"], // Location of the error
              "msg": "Specific error message for this field",   // Human-readable message
              "type": "validation_error_type"                  // Pydantic's internal error type
            }
            // ... potentially more error objects for other fields
          ]
        }
        ```

2.  **Errors from Custom `ApplicationException` Subclasses (e.g., `NotFoundError`, `ConflictError`):**
    *   The HTTP status code is defined by the specific exception (e.g., 404, 409).
    *   The response body is generated by the exception's `to_dict()` method:
        ```json
        {
          "message": "A human-readable error summary specific to the exception type"
          // "field_specific_key": "Any additional details included in the exception's payload dictionary"
        }
        ```
        *Example for `PortfolioNotFoundError(portfolio_id=123)`:*
        ```json
        {
          "message": "The specified portfolio was not found."
          // "portfolio_id": 123 // If added to payload in a specific handler
        }
        ```

3.  **Errors from Explicit `abort(code, description)` or Unhandled Werkzeug HTTPExceptions:**
    *   For specific handled codes (`400`, `401`, `403`, `404`, `500`) via `@app.errorhandler(code)` in `error_handlers.py`:
        ```json
        {
          "error": "A human-readable description of the error." 
          // e.g., "The requested resource was not found." for 404
          // e.g., "Authentication is required..." for 401
        }
        ```
    *   For other `HTTPException`s caught by the generic `@app.errorhandler(HTTPException)`:
        ```json
        {
          "code": 418, // The specific HTTP status code
          "name": "I'm a teapot", // The standard name of the error
          "description": "The server refuses the attempt to brew coffee with a teapot." // Detailed description
        }
        ```
        This generic handler is a fallback and might be less common for typical API client errors.

4.  **`500 Internal Server Error` (from unhandled exceptions or explicit `abort(500)`):**
    *   The specific handler `handle_500_internal_server_error` returns:
        ```json
        {
          "error": "An internal server error occurred. Please try again later." 
          // Or the description from abort(500, "custom message")
        }
        ```
    *   Detailed error information is logged on the server-side but not exposed to the client.

---

## Authentication Endpoints

**1. Register User**
* **Method:** `POST`
* **Path:** `/auth/register`
* **Description:** Creates a new user account. The user's password strength is validated, and it's checked against the Pwned Passwords database (this check is fail-open, meaning registration proceeds if the check itself fails).
* **Request Body:** (`application/json`, based on `UserRegistrationSchema`)
    ```json
    {
      "username": "newuser", // string, required, min_length: 3, max_length: 64
      "email": "user@example.com", // string, required, valid email format
      "password": "Str0ngP@sswOrd!" // string, required, min_length: 8 (additional complexity rules may apply as per backend logic, e.g. uppercase, lowercase, digit, special character)
    }
    ```
* **Success Response:** `201 Created` (Returns the newly created user object, based on `UserSchema`)
    ```json
    {
      "id": 1, // integer, user's unique ID
      "username": "newuser", // string
      "email": "user@example.com", // string
      "created_at": "2023-10-27T10:30:00Z" // string, datetime ISO 8601 format
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., missing fields, email format incorrect, password too short). Response structure will follow "Pydantic Schema Validation" error format. Can also occur if password found in Pwned Passwords database.
    * `409 Conflict`: Username or email already exists. Response structure will follow "Custom ApplicationException" format (e.g., `{"message": "Username or email already exists."}`).

**2. Login User**
* **Method:** `POST`
* **Path:** `/auth/login`
* **Description:** Authenticates a user using their username or email and password. Returns an access token in the response body and a refresh token as a secure, HttpOnly cookie.
* **Request Body:** (`application/json`, based on `UserLoginSchema`)
    ```json
    {
      "username_or_email": "newuser", // string, required, can be username or email
      "password": "Str0ngP@sswOrd!" // string, required
    }
    ```
* **Success Response:** `200 OK`
    ```json
    {
      "message": "Login successful.", // string
      "access_token": "your_jwt_access_token_here", // string, JWT
      "user": { // object, user details based on UserSchema
        "id": 1, // integer
        "username": "newuser", // string
        "email": "user@example.com", // string
        "created_at": "2023-10-27T10:30:00Z" // string, datetime ISO 8601
      }
      // Note: The refresh_token is set as an HttpOnly cookie by the server and is not included in this JSON response.
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., missing fields). Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Invalid username/email or password. Response structure: "Custom ApplicationException" (e.g., `{"message": "Invalid username/email or password."}`).

**3. Refresh Token**
* **Method:** `POST`
* **Path:** `/auth/refresh`
* **Description:** Obtains a new access token using a valid refresh token. The refresh token **MUST** be sent by the client as a secure, HttpOnly cookie.
* **Authentication:** Requires a valid refresh token cookie.
* **Request Body:** None.
* **Success Response:** `200 OK`
    ```json
    {
      "access_token": "new_jwt_access_token_here" // string, JWT
    }
    ```
* **Error Responses:**
    * `401 Unauthorized`: Invalid, expired, or missing refresh token cookie. Response structure: "Explicit abort()" (e.g., `{"error": "Missing refresh token cookie"}` or similar from Flask-JWT-Extended).

**4. Logout User**
* **Method:** `POST`
* **Path:** `/auth/logout`
* **Description:** Invalidates the user's session by unsetting the refresh token cookie. The client is responsible for discarding the access token.
* **Authentication:** Requires a valid access token in the `Authorization` header.
* **Request Body:** None.
* **Success Response:** `200 OK`
    ```json
    {
      "message": "Logout successful. Please discard your access token." // string
    }
    ```
* **Error Responses:**
    * `401 Unauthorized`: Missing or invalid access token. Response structure: "Explicit abort()" (e.g., `{"error": "Missing Authorization Header"}` or similar from Flask-JWT-Extended).

*(Note: Password Reset endpoints are planned but not yet detailed in this version of the specification.)*

---

## Portfolio Endpoints

All endpoints under `/portfolios` require authentication. User must own the portfolio for operations on a specific portfolio.

**1. Get User's Portfolios**
* **Method:** `GET`
* **Path:** `/` (i.e., `/portfolios/`)
* **Description:** Retrieves a paginated, sorted, and optionally filtered list of portfolios belonging to the authenticated user.
* **Query Parameters (Optional):**
    * `page` (integer, default: 1, min: 1): Page number for pagination.
    * `per_page` (integer, default: 10, min: 1, max: 100): Number of items per page.
    * `sort_by` (string, default: "created_at", allowed: "name", "created_at", "updated_at"): Field to sort portfolios by.
    * `sort_order` (string, default: "desc", allowed: "asc", "desc"): Sort order.
    * `filter_name` (string, optional, min_length: 1, max_length: 100): Filter portfolios by name (case-insensitive, partial match).
* **Request Body:** None
* **Success Response:** `200 OK` (Returns a list of portfolio summaries based on `PortfolioSummarySchema` and pagination details)
    ```json
    {
      "data": [
        {
          "portfolioId": 1, // integer (alias for portfolio_id)
          "userId": 123, // integer
          "name": "Retirement Plan", // string
          "description": "My long term retirement savings", // string, optional
          "totalValue": "150000.00", // string (decimal), calculated summary
          "createdAt": "2024-03-10T09:00:00Z", // string, datetime ISO 8601
          "updatedAt": "2024-03-12T14:30:00Z"  // string, datetime ISO 8601
        }
        // ... more portfolio summary objects
      ],
      "pagination": {
        "page": 1,
        "per_page": 10,
        "total_pages": 1,
        "total_items": 1,
        "next_page": null, // integer or null
        "prev_page": null, // integer or null
        "has_next": false,
        "has_prev": false
      }
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid query parameters (e.g., non-integer page, invalid sort_by field). Response structure: "Pydantic Schema Validation" or "Explicit abort()".
    * `401 Unauthorized`: Missing or invalid access token.

**2. Create Portfolio**
* **Method:** `POST`
* **Path:** `/` (i.e., `/portfolios/`)
* **Description:** Creates a new portfolio for the authenticated user.
* **Request Body:** (`application/json`, based on `PortfolioCreateSchema`)
    ```json
    {
      "name": "New Investment Portfolio", // string, required, min_length: 1
      "description": "Optional description for the portfolio" // string, optional
    }
    ```
* **Success Response:** `201 Created` (Returns the newly created portfolio object, based on `PortfolioSchema`)
    ```json
    {
      "portfolioId": 3, // integer (alias for portfolio_id)
      "userId": 123, // integer
      "name": "New Investment Portfolio", // string
      "description": "Optional description for the portfolio", // string, optional
      "totalValue": "0.00", // string (decimal), initial value
      "assets": [], // list, empty for a new portfolio
      "plannedChanges": [], // list, empty for a new portfolio
      "createdAt": "2024-03-15T10:00:00Z", // string, datetime ISO 8601
      "updatedAt": "2024-03-15T10:00:00Z"  // string, datetime ISO 8601
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., missing name). Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Missing or invalid access token.

**3. Get Portfolio Details**
* **Method:** `GET`
* **Path:** `/{portfolio_id}/`
* **Description:** Retrieves details for a specific portfolio, including associated assets and planned changes based on the `include` parameter. Requires user ownership of the portfolio.
* **Query Parameters (Optional):**
    * `include` (string, default: "full"): Specifies which related entities to include.
        * Valid values:
            * `summary`: Returns only the portfolio's top-level details (matching `PortfolioSummarySchema` effectively, but still serialized via `PortfolioSchema` with exclusions).
            * `assets`: Includes portfolio details and the `assets` array. `plannedChanges` will be empty or omitted.
            * `changes`: Includes portfolio details and the `plannedChanges` array. `assets` will be empty or omitted.
            * `full`: Includes portfolio details, `assets`, and `plannedChanges` arrays.
* **Request Body:** None
* **Success Response:** `200 OK` (Returns the portfolio object based on `PortfolioSchema`, with content varying by `include` param)
    *Example (with `include=full` or default):*
    ```json
    {
      "portfolioId": 1, // integer
      "userId": 123, // integer
      "name": "Retirement Plan", // string
      "description": "My long term retirement savings", // string, optional
      "totalValue": "150000.00", // string (decimal)
      "assets": [ // list of AssetSchema objects
        { 
          "id": 101, // integer (alias for asset_id)
          "portfolioId": 1, // integer
          "assetType": "Stock", // string, enum (e.g., "Stock", "Bond")
          "name": "AAPL", // string (alias for name_or_ticker)
          "allocationPercentage": "60.00", // string (decimal)
          "allocationValue": null, // string (decimal) or null
          "manualExpectedReturn": "7.50", // string (decimal) or null
        }
      ],
      "plannedChanges": [ // list of PlannedChangeSchema objects
        { 
          "id": 201, // integer (alias for change_id)
          "portfolioId": 1, // integer
          "changeType": "Contribution", // string, enum
          "changeDate": "2024-08-01", // string, "YYYY-MM-DD"
          "amount": "500.00", // string (decimal)
          "targetAllocationJson": null, // object or null
          "description": "Monthly top-up", // string, optional
          "isRecurring": false, // boolean
          "frequency": "ONE_TIME", // string, enum
          "interval": 1, // integer
          "daysOfWeek": null, // list of integers or null
          "dayOfMonth": null, // integer or null
          "monthOrdinal": null, // string, enum or null
          "monthOrdinalDay": null, // string, enum or null
          "monthOfYear": null, // integer or null
          "endsOnType": "NEVER", // string, enum
          "endsOnOccurrences": null, // integer or null
          "endsOnDate": null // string, "YYYY-MM-DD" or null
        }
      ],
      "createdAt": "2024-03-10T09:00:00Z", // string, datetime ISO 8601
      "updatedAt": "2024-03-12T14:30:00Z"  // string, datetime ISO 8601
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid `include` parameter value.
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

**4. Update Portfolio**
* **Method:** `PUT` or `PATCH`
* **Path:** `/{portfolio_id}/`
* **Description:** Updates specified details for a portfolio (e.g., name, description). Requires user ownership.
* **Request Body:** (`application/json`, based on `PortfolioUpdateSchema` - fields are optional)
    ```json
    {
      "name": "Updated Portfolio Name", // string, optional, min_length: 1
      "description": "Updated description" // string, optional
    }
    ```
* **Success Response:** `200 OK` (Returns the updated portfolio object, based on `PortfolioSchema`)
    ```json
    {
      "portfolioId": 1,
      "userId": 123,
      "name": "Updated Portfolio Name", // string
      "description": "Updated description", // string, optional
      "totalValue": "150000.00", // string (decimal), value may not change with this operation
      "assets": [ /* ... existing assets ... */ ],
      "plannedChanges": [ /* ... existing planned changes ... */ ],
      "createdAt": "2024-03-10T09:00:00Z",
      "updatedAt": "2024-03-15T11:00:00Z" // string, datetime, will be updated
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data. Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

**5. Delete Portfolio**
* **Method:** `DELETE`
* **Path:** `/{portfolio_id}/`
* **Description:** Deletes a specific portfolio and all its associated data (assets, planned changes due to database cascade). Requires user ownership.
* **Request Body:** None
* **Success Response:** `200 OK`
    ```json
    {
      "message": "Portfolio with ID 1 and all its associated data deleted successfully." // string
    }
    ```
* **Error Responses:**
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

---

## Asset Endpoints (Nested under Portfolios)

**1. Add Asset to Portfolio**
* **Method:** `POST`
* **Path:** `/portfolios/{portfolio_id}/assets`
* **Description:** Adds a new asset to a specific portfolio. Requires Authentication and authorization.
* **Request Body:**
    ```json
    {
      "asset_type": "Stock", // string, required, enum. Valid values: ["Stock", "Bond", "Mutual Fund", "ETF", "Real Estate", "Cash", "Cryptocurrency", "Options", "Other"]
      "name_or_ticker": "AAPL", // string, required
      "allocation_percentage": "60.50", // string, optional, decimal between "0.00" and "100.00". See allocation rules.
      "allocation_value": "10000.00", // string, optional, decimal >= "0.00". See allocation rules.
      "manual_expected_return": "7.5" // string, optional, decimal representing annual return percentage (e.g., "7.5" for 7.5%)
    }
    ```
    *Allocation Exclusivity & Defaults:*
    *   It is **strongly recommended** to provide EITHER `allocation_percentage` OR `allocation_value`, but not both non-null.
    *   If `allocation_percentage` is set (non-null), any provided `allocation_value` will typically be ignored and set to `null` by the backend (due to model validators).
    *   If `allocation_value` is set (non-null), any provided `allocation_percentage` will typically be ignored and set to `null` by the backend.
    *   If both are sent non-null, the backend's behavior (which field takes precedence and which is nulled) depends on internal validation order; to ensure predictable behavior, send only one.
    *   If neither is provided, `allocation_percentage` defaults to `"0.00"` and `allocation_value` will be `null`.
* **Success Response:** `201 Created` (Returns the newly created asset object)
    ```json
    {
        "asset_id": 101, // integer
        "portfolio_id": 1, // integer
        "asset_type": "Stock", // string, enum
        "name_or_ticker": "AAPL", // string
        "allocation_percentage": "60.50", // string, decimal (or "0.00" if defaulted, or null if value was prioritized)
        "allocation_value": null, // string, decimal (or populated if value was provided and percentage was null)
        "manual_expected_return": "7.50", // string, decimal (formatted to two decimal places)
        "created_at": "2024-03-15T10:00:00Z", // string, datetime ISO 8601
        "updated_at": "2024-03-15T10:00:00Z" // string, datetime ISO 8601
    }
    ```
* **Error Responses:** `400 Bad Request` (Invalid input, validation errors), `401 Unauthorized`, `403 Forbidden`, `404 Not Found` (Portfolio)

**2. Update Asset**
* **Method:** `PUT` or `PATCH` (`PUT` here accepts partial updates of the asset resource, similar to `PATCH`. Clients can send only the fields they wish to change.)
* **Path:** `/portfolios/{portfolio_id}/assets/{asset_id}`
* **Description:** Updates an existing asset. Requires Authentication and authorization. Only fields to be updated need to be sent.
* **Request Body:** (Include fields to update, all are optional)
    ```json
    {
      "asset_type": "Stock", // string, optional, enum. Valid values: ["Stock", "Bond", "Mutual Fund", "ETF", "Real Estate", "Cash", "Cryptocurrency", "Options", "Other"]
      "name_or_ticker": "Apple Inc.", // string, optional
      "allocation_percentage": "55.00", // string, optional, decimal. See allocation update rules.
      "allocation_value": null, // string, optional, decimal or null. See allocation update rules.
      "manual_expected_return": "8.0" // string, optional, decimal
    }
    ```
    *Allocation Exclusivity on Update:*
    *   Similar to adding an asset, if `allocation_percentage` is updated to a non-null value, `allocation_value` will be set to `null` by the backend validator.
    *   If `allocation_value` is updated to a non-null value, `allocation_percentage` will be set to `null` by the backend validator.
    *   It's recommended to only send one of these fields for update if changing allocation basis, or set one to `null` explicitly if switching.
* **Success Response:** `200 OK` (Returns the updated asset object)
    ```json
    {
        "asset_id": 101,
        "portfolio_id": 1,
        "asset_type": "Stock",
        "name_or_ticker": "Apple Inc.",
        "allocation_percentage": "55.00",
        "allocation_value": null,
        "manual_expected_return": "8.00",
        "created_at": "2024-03-15T10:00:00Z", // Original creation date
        "updated_at": "2024-03-15T10:05:00Z"  // Timestamp of this update
    }
    ```
* **Error Responses:** `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found` (Portfolio or Asset)

**3. Delete Asset**
* **Method:** `DELETE`
* **Path:** `/portfolios/{portfolio_id}/assets/{asset_id}`
* **Description:** Removes an asset from a portfolio. Requires Authentication and authorization.
* **Success Response:** `200 OK` or `204 No Content`
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., invalid enum value for `assetType`, non-numeric string for decimal fields). Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

**2. Update Asset**
* **Method:** `PUT` or `PATCH`
* **Path:** `/portfolios/{portfolio_id}/assets/{asset_id}/`
* **Description:** Updates an existing asset within a specific portfolio. Requires user ownership. Only fields present in the request body will be updated. If `allocationPercentage` is updated, `allocationValue` will be nulled by the backend, and vice-versa, to maintain exclusivity.
* **Request Body:** (`application/json`, based on `AssetUpdateSchema` - all fields optional)
    ```json
    {
      "assetType": "Bond", // string, optional, enum from AssetType
      "name": "Corporate Bond XYZ", // string, optional (alias for name_or_ticker)
      "allocationPercentage": "40.00", // string (decimal "X.XX"), optional, 0-100
      "allocationValue": null, // string (decimal "X.XX") or null, optional, >= 0
      "manualExpectedReturn": "4.5" // string (decimal "X.X"), optional
    }
    ```
* **Success Response:** `200 OK` (Returns the updated asset object, based on `AssetSchema`)
    ```json
    {
        "id": 101, // integer (alias for asset_id)
        "portfolioId": 1, // integer
        "assetType": "Bond",
        "name": "Corporate Bond XYZ",
        "allocationPercentage": "40.00", // string (decimal)
        "allocationValue": null, // string (decimal) or null
        "manualExpectedReturn": "4.50" // string (decimal, formatted)
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data.
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio or Asset with the given ID does not exist.

**3. Delete Asset**
* **Method:** `DELETE`
* **Path:** `/portfolios/{portfolio_id}/assets/{asset_id}/`
* **Description:** Removes an asset from a specific portfolio. Requires user ownership.
* **Request Body:** None
* **Success Response:** `200 OK`
    ```json
    {
      "message": "Asset deleted successfully" // string
    }
    ```
* **Error Responses:**
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio or Asset with the given ID does not exist.

---

## Allocation Endpoints (Nested under Portfolios)

These endpoints manage asset allocations within a specific portfolio. All paths are prefixed with `/portfolios/{portfolio_id}/allocations`. Requires user ownership of the portfolio.

**1. Update Portfolio Allocations**
* **Method:** `PUT`
* **Path:** `/` (i.e., `/portfolios/{portfolio_id}/allocations/`)
* **Description:** Updates the allocation percentages for **all** assets within a specific portfolio simultaneously. This action sets the `allocationValue` of all involved assets to `null`, as the portfolio transitions to a purely percentage-based allocation model for these assets.
* **Request Body:** (`application/json`, based on `BulkAllocationUpdateSchema`)
    ```json
    {
      "allocations": [ // list of AssetAllocationSchema objects
        { "assetId": 101, "allocationPercentage": "45.50" }, // assetId: integer (alias for asset_id), required; allocationPercentage: string (decimal "X.XX"), required, 0-100
        { "assetId": 102, "allocationPercentage": "30.00" },
        { "assetId": 105, "allocationPercentage": "24.50" }
      ]
    }
    ```
    *Validation Rules (enforced by backend):*
    *   The `allocationPercentage` for each asset must be a string representation of a decimal (e.g., "45.50").
    *   The sum of all `allocationPercentage` values in the `allocations` array **MUST** be exactly `"100.00"` (within a small tolerance like 99.99-100.01 due to decimal representations).
    *   The `allocations` array **MUST** include an entry for **EVERY** asset currently belonging to the specified portfolio. Omitting an asset or including an `assetId` not in the portfolio will result in a `400 Bad Request`.
* **Success Response:** `200 OK`
    ```json
    {
        "message": "Allocations for all assets updated successfully." // string
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., percentages don't sum to 100, asset ID mismatch between payload and portfolio, incorrect data types). Response structure: "Pydantic Schema Validation" or "Custom ApplicationException".
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

---

## Planned Future Change Endpoints (Nested under Portfolios)

These endpoints manage scheduled future changes to a portfolio, such as recurring contributions, withdrawals, or reallocations. All paths are prefixed with `/portfolios/{portfolio_id}/changes`. Requires user ownership of the portfolio. Fields in JSON are camelCased due to schema configuration.

**1. Add Planned Change**
*   **Method:** `POST`
*   **Path:** `/` (i.e., `/portfolios/{portfolio_id}/changes/`)
*   **Description:** Adds a new planned future change to a specific portfolio.
*   **Request Body:** (`application/json`, based on `PlannedChangeCreateSchema`)
    ```json
    {
      "changeType": "Contribution", // string, required. Valid values from ChangeType enum: ["Contribution", "Withdrawal", "Reallocation", "Dividend", "Interest"]
      "changeDate": "2025-01-15", // string, required, "YYYY-MM-DD" format (start date for recurring changes)
      "amount": "500.00", // string (decimal "X.XX"), conditionally required. Required if changeType is 'Contribution' or 'Withdrawal'. Must be null or omitted if changeType is 'Reallocation'.
      "targetAllocationJson": null, // JSON object (dictionary), conditionally required. Required and used only if changeType is 'Reallocation'. Must be null or omitted otherwise. Structure: { "asset_id_as_string_key": "percentage_as_string_value", ... } Example: { "101": "50.00", "102": "50.00" } (asset IDs are strings, percentages are strings, sum to "100.00").
      "description": "Monthly savings contribution", // string, optional, max_length: 255
      "isRecurring": true, // boolean, optional, defaults to false.
      // --- Recurrence Fields (conditionally required/validated based on isRecurring and frequency) ---
      "frequency": "MONTHLY", // string, optional, defaults to 'ONE_TIME'. Valid values from FrequencyType: ["ONE_TIME", "DAILY", "WEEKLY", "MONTHLY", "YEARLY"]
      "interval": 1, // integer, optional, default: 1, must be >= 1.
      "daysOfWeek": null, // array of integers (0-6, 0=Monday), optional. Used if frequency is 'WEEKLY'. Example: [0, 2, 4] for Mon, Wed, Fri.
      "dayOfMonth": 15, // integer, optional, [1-31]. Used if frequency is 'MONTHLY'/'YEARLY' and not using ordinal recurrence.
      "monthOrdinal": null, // string, optional. Valid values from MonthOrdinalType: ["FIRST", "SECOND", "THIRD", "FOURTH", "LAST"]
      "monthOrdinalDay": null, // string, optional. Valid values from OrdinalDayType: ["MONDAY", "TUESDAY", ..., "SUNDAY", "DAY", "WEEKDAY", "WEEKEND_DAY"]
      "monthOfYear": null, // integer, optional, [1-12]. Used if frequency is 'YEARLY'.
      "endsOnType": "AFTER_OCCURRENCES", // string, optional, defaults to 'NEVER'. Valid values from EndsOnType: ["NEVER", "AFTER_OCCURRENCES", "ON_DATE"]
      "endsOnOccurrences": 12, // integer, optional, must be >= 1. Used if endsOnType is 'AFTER_OCCURRENCES'.
      "endsOnDate": null // string ("YYYY-MM-DD"), optional. Used if endsOnType is 'ON_DATE'.
    }
    ```
    *Validation notes: Schema validators enforce consistency (e.g., `daysOfWeek` only for weekly, `amount` based on `changeType`).*
*   **Success Response:** `201 Created` (Returns the newly created planned change object, based on `PlannedChangeSchema`)
    ```json
    {
      "id": 301, // integer (alias for change_id)
      "portfolioId": 1, // integer
      "changeType": "Contribution",
      "changeDate": "2025-01-15",
      "amount": "500.00",
      "targetAllocationJson": null,
      "description": "Monthly savings contribution",
      "isRecurring": true,
      "frequency": "MONTHLY",
      "interval": 1,
      "daysOfWeek": null,
      "dayOfMonth": 15,
      "monthOrdinal": null,
      "monthOrdinalDay": null,
      "monthOfYear": null,
      "endsOnType": "AFTER_OCCURRENCES",
      "endsOnOccurrences": 12,
      "endsOnDate": null
      // "createdAt" and "updatedAt" fields are part of the model but not explicitly in PlannedChangeSchema base or PlannedChangeSchema.
      // If they are present in the model and OrmBaseModel, they would appear here. Assuming they are not for now based on provided schemas.
    }
    ```
*   **Error Responses:**
    *   `400 Bad Request`: Invalid input or validation failure (e.g., missing conditional fields, invalid enum values, logical conflicts in recurrence rules). Response structure: "Pydantic Schema Validation".
    *   `401 Unauthorized`: Missing or invalid access token.
    *   `403 Forbidden`: User does not own the portfolio.
    *   `404 Not Found`: Portfolio with the given ID does not exist.

**2. Update Planned Change**
*   **Method:** `PUT` or `PATCH`
*   **Path:** `/{change_id}/` (i.e., `/portfolios/{portfolio_id}/changes/{change_id}/`)
*   **Description:** Updates an existing planned future change. Send only the fields to be modified. Backend performs post-update consistency checks (e.g., if `changeType` is updated to 'Contribution', an `amount` must exist or be provided).
*   **Request Body:** (`application/json`, based on `PlannedChangeUpdateSchema` - all fields are optional)
    ```json
    {
      "changeType": "Withdrawal", // string, optional, enum from ChangeType
      "changeDate": "2025-02-01", // string, optional, "YYYY-MM-DD"
      "amount": "200.00", // string (decimal "X.XX"), optional
      "description": "Updated description", // string, optional
      "endsOnOccurrences": 10 // integer, optional
      // ... any other fields from PlannedChangeBase can be included ...
    }
    ```
*   **Success Response:** `200 OK` (Returns the updated planned change object, based on `PlannedChangeSchema`)
    ```json
    {
      "id": 301,
      "portfolioId": 1,
      "changeType": "Withdrawal",
      "changeDate": "2025-02-01",
      "amount": "200.00",
      "targetAllocationJson": null,
      "description": "Updated description",
      "isRecurring": true, // Assuming this was not changed
      "frequency": "MONTHLY", // Assuming this was not changed
      "interval": 1,
      "dayOfMonth": 15, // Assuming this was not changed
      "endsOnType": "AFTER_OCCURRENCES",
      "endsOnOccurrences": 10
      // "createdAt", "updatedAt" would appear if part of the model & schema as above.
    }
    ```
*   **Error Responses:**
    *   `400 Bad Request`: Invalid input or validation failure.
    *   `401 Unauthorized`: Missing or invalid access token.
    *   `403 Forbidden`: User does not own the portfolio.
    *   `404 Not Found`: Portfolio or Planned Change with the given ID does not exist.

**3. Delete Planned Change**
*   **Method:** `DELETE`
*   **Path:** `/{change_id}/` (i.e., `/portfolios/{portfolio_id}/changes/{change_id}/`)
*   **Description:** Deletes a specific planned future change from a portfolio.
*   **Request Body:** None
*   **Success Response:** `200 OK`
    ```json
    {
      "message": "Planned change deleted successfully" // string
    }
    ```
*   **Error Responses:**
    *   `401 Unauthorized`: Missing or invalid access token.
    *   `403 Forbidden`: User does not own the portfolio.
    *   `404 Not Found`: Portfolio or Planned Change with the given ID does not exist.

---

## Projection Endpoint

These endpoints manage portfolio projections. All paths are prefixed with `/portfolios/{portfolio_id}/projections`. Requires user ownership of the portfolio. Fields in JSON are camelCased.

**1. Run Projection (Task-Based)**
* **Method:** `POST`
* **Path:** `/` (i.e., `/portfolios/{portfolio_id}/projections/`)
* **Description:** Initiates a portfolio projection calculation as a background Celery task.
* **Request Body:** (`application/json`, based on `ProjectionTaskRequestSchema`)
    ```json
    {
      "startDate": "2025-01-01", // string, required, "YYYY-MM-DD" format
      "endDate": "2055-01-01",   // string, required, "YYYY-MM-DD" format, must be after startDate
      "initialTotalValue": "10000.00" // string (decimal "X.XX"), required, must be >= "0.00"
    }
    ```
* **Success Response:** `202 Accepted`
    ```json
    {
      "message": "Projection task accepted and is being processed.", // string
      "task_id": "your_unique_celery_task_id_here" // string, UUID
    }
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., `endDate` not after `startDate`, negative `initialTotalValue`, invalid date format). Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.
    * `500 Internal Server Error`: Failed to dispatch Celery task or record task status.

**2. Get Projection Preview (Direct Calculation)**
* **Method:** `POST`
* **Path:** `/preview/` (i.e., `/portfolios/{portfolio_id}/projections/preview/`)
* **Description:** Calculates and returns a portfolio projection preview synchronously.
* **Request Body:** (`application/json`, based on `ProjectionPreviewRequestSchema`)
    ```json
    {
      "startDate": "2025-01-01", // string, required, "YYYY-MM-DD"
      "endDate": "2030-01-01",   // string, required, "YYYY-MM-DD", must be after startDate
      "initialTotalValue": "10000.00", // string (decimal "X.XX"), required, >= "0.00"
      "draftPlannedChanges": [ // array, optional. Each object conforms to PlannedChangeCreateSchema (see "Add Planned Change" endpoint for structure).
        {
          "changeType": "Contribution",
          "changeDate": "2025-02-01",
          "amount": "100.00",
          "isRecurring": true,
          "frequency": "MONTHLY",
          "interval": 1,
          "dayOfMonth": 1,
          "endsOnType": "NEVER"
          // ... other fields as per PlannedChangeCreateSchema ...
        }
        // ... more draft planned change objects ...
      ]
    }
    ```
* **Success Response:** `200 OK`
    ```json
    [ // Array of data points
        { "date": "2025-12-31", "value": "10700.00" }, // date: string "YYYY-MM-DD", value: string (decimal "X.XX")
        { "date": "2026-12-31", "value": "11449.00" },
        // ... more data points for each period end (e.g., end of year or end of month, depending on projection granularity)
    ]
    ```
* **Error Responses:**
    * `400 Bad Request`: Invalid input data (e.g., `endDate` not after `startDate`, negative `initialTotalValue`, invalid `draftPlannedChanges` structure). Response structure: "Pydantic Schema Validation".
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.
    * `500 Internal Server Error`: Error during direct calculation.

---

## Analytics Endpoints (Nested under Portfolios)

These endpoints provide analytical data for a portfolio. All paths are prefixed with `/portfolios/{portfolio_id}/analytics`. Requires user ownership of the portfolio. Fields in JSON are camelCased.

**1. Get Portfolio Risk Profile**
* **Method:** `GET`
* **Path:** `/risk-profile/` (i.e., `/portfolios/{portfolio_id}/analytics/risk-profile/`)
* **Description:** Retrieves the risk profile analysis for a specific portfolio. (Currently returns placeholder data).
* **Request Body:** None
* **Success Response:** `200 OK` (Body based on `RiskProfileSchema`)
    ```json
    {
      "riskScore": 0.75, // number (float/double), 0-1
      "volatilityEstimate": 0.15, // number (float/double), optional, >= 0
      "sharpeRatio": 1.2, // number (float/double), optional
      "confidenceIntervalLow95": -0.05, // number (float/double), optional
      "confidenceIntervalHigh95": 0.25, // number (float/double), optional
      "calculationDate": "2024-03-21" // string, "YYYY-MM-DD"
    }
    ```
* **Error Responses:**
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

**2. Get Portfolio Performance**
* **Method:** `GET`
* **Path:** `/performance/` (i.e., `/portfolios/{portfolio_id}/analytics/performance/`)
* **Description:** Retrieves historical or simulated performance data for a specific portfolio.
* **Query Parameters (Optional):**
    * `startDate` (string, "YYYY-MM-DD"): Defaults to 30 days prior to current date.
    * `endDate` (string, "YYYY-MM-DD"): Defaults to current date. Must not be in the future. `startDate` must be <= `endDate`.
* **Request Body:** None
* **Success Response:** `200 OK`
    ```json
    [ // Array of performance data points
      {"date": "2024-01-01", "cumulativeReturn": 0.0}, // cumulativeReturn: number (float/double), total return since start_date (e.g., 0.05 for 5%)
      {"date": "2024-01-02", "cumulativeReturn": 0.001},
      {"date": "2024-01-03", "cumulativeReturn": 0.002}
      // ... more data points, typically daily or monthly depending on range and backend logic
    ]
    ```
    *(Note: The exact structure of performance data points, especially the "cumulativeReturn" field, depends on the `calculate_historical_performance` service implementation.)*
* **Error Responses:**
    * `400 Bad Request`: Invalid date format or range (e.g., `startDate` after `endDate`).
    * `401 Unauthorized`: Missing or invalid access token.
    * `403 Forbidden`: User does not own the portfolio.
    * `404 Not Found`: Portfolio with the given ID does not exist.

---

## Task Endpoints

These endpoints manage background tasks, such as those initiated for portfolio projections. All paths are prefixed with `/tasks`. Requires authentication.

**1. Get Task Status**
* **Method:** `GET`
* **Path:** `/{task_id}` (i.e., `/tasks/{task_id}`)
* **Description:** Retrieves the status and result (if available) of a specific background task. Ensures that the task being queried was initiated by the authenticated user.
* **Request Body:** None
* **Success Response:** `200 OK` (The structure of the `result` field depends on the task type and its completion state)
    *Example for a task that is **pending, processing, or failed** (non-specific result):*
    ```json
    {
      "task_id": "abc-123-def-456", // string, Celery Task ID (UUID)
      "status": "PENDING", // string, current state of the task. Possible values: "PENDING", "PROCESSING", "FAILED"
      "result": null, // object or any, typically null if not completed successfully or if no specific data is returned on failure
      "error": null // string or object, null if task is not in FAILED state. If FAILED, contains error message or details.
    }
    ```
    *Example for a **successfully COMPLETED portfolio projection** task:*
    ```json
    {
      "task_id": "xyz-789-uvw-012", // string, Celery Task ID (UUID)
      "status": "COMPLETED", // string, current state of the task
      "result": { // object, content depends on the task type
        "message": "Projection calculated successfully.", // string, optional general message
        "data": { // object, contains the actual projection results. Dates are keys, string decimal values are values.
          "2025-12-31": "10700.00", 
          "2026-12-31": "11449.00"
          // ... more date-value pairs for each period end
        }
      },
      "error": null // string or object, null for successful completion
    }
    ```
* **Possible Status Values (Common Celery States):**
    *   `PENDING`: Task is waiting for execution or has not been reported yet.
    *   `PROCESSING`: Task is currently being executed by a worker. (Note: `task_service.py` might map Celery's `STARTED` or `RETRY` to this or a similar state like `PROCESSING`).
    *   `COMPLETED`: Task finished successfully. (`result` will be populated). (Note: Celery's state is `SUCCESS`).
    *   `FAILED`: Task failed during execution. (`error` will be populated, `result` might contain partial data or be null). (Note: Celery's state is `FAILURE`).
* **Error Responses:**
    * `401 Unauthorized`: Missing or invalid access token.
    * `404 Not Found`: Task ID does not exist or is not associated with the authenticated user.
    * `500 Internal Server Error`: Unexpected error while fetching task status.