/* === M3 Button Base Styles === */
.button {
  /* Layout & Box Model */
  position: relative; /* Needed for state layer positioning */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle; /* Align with text */
  box-sizing: border-box;
  min-width: 64px;
  height: 40px; /* M3 default height */
  padding: 0 24px; /* Horizontal padding (icon buttons override this) */
  border: none; /* Use outlines/backgrounds for variants */
  border-radius: var(--m3-shape-corner-full); /* Fully rounded */
  overflow: hidden; /* Clip state layer */

  /* Typography */
  font-family: var(--m3-type-label-large-font);
  font-size: var(--m3-type-label-large-size);
  font-weight: var(--m3-type-label-large-weight);
  line-height: var(--m3-type-label-large-line-height); /* Should match height */
  letter-spacing: var(--m3-type-label-large-letter-spacing);
  white-space: nowrap;
  text-decoration: none;
  text-transform: none; /* M3 uses sentence case */

  /* Interaction & Appearance */
  cursor: pointer;
  user-select: none;
  -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */

  /* Transitions (using M3 tokens) */
  transition:
    background-color var(--m3-motion-duration-short4) var(--m3-motion-easing-standard),
    box-shadow var(--m3-motion-duration-short4) var(--m3-motion-easing-standard),
    border-color var(--m3-motion-duration-short4) var(--m3-motion-easing-standard),
    color var(--m3-motion-duration-short4) var(--m3-motion-easing-standard);
}

.button:focus {
  outline: none; /* Handled by focus state layer */
}

/* === State Layer === */
.stateLayer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: currentColor; /* Default to text color, variants override */
  opacity: 0;
  pointer-events: none; /* Allow clicks to pass through */
  transition: opacity var(--m3-motion-duration-short2) var(--m3-motion-easing-standard);
}

.button:hover > .stateLayer {
  opacity: var(--m3-state-hover-opacity);
}

.button:focus-visible > .stateLayer {
  opacity: var(--m3-state-focus-opacity);
}

.button:active > .stateLayer {
  opacity: var(--m3-state-pressed-opacity);
}

/* === Icon & Text Styling === */
.icon,
.spinner {
  /* Using 18dp size as per M3 spec */
  width: 18px;
  height: 18px;
  display: block;
  flex-shrink: 0;
  /* Color should inherit from button */
}

/* Adjust spacing when icon is present */
.icon + .text {
  margin-left: 8px; /* 8dp gap */
}
.text + .icon { /* For trailing icon, if ever needed */
  margin-left: 8px;
}

/* Loading state specific styles */
.loading .icon { /* Hide original icon when loading */
  display: none;
}
.loading .spinner { /* Show spinner */
  display: block;
}
.loading .text {
  /* Optionally reduce opacity or add space */
  margin-left: 8px; /* Ensure space for spinner */
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.spinner {
  animation: spin 1s linear infinite;
}

/* === Icon Only Button === */
.iconOnly {
  min-width: 40px; /* Square aspect ratio */
  width: 40px;
  height: 40px;
  padding: 0; /* Remove padding */
}

.iconOnly .icon,
.iconOnly .spinner {
  /* Center the icon */
  margin: 0;
}

/* === Specific overrides for iconOnly buttons === */
/* Default icon color for standard variants when iconOnly */
.iconOnly.outlined,
.iconOnly.text,
.iconOnly.elevated,
.iconOnly.tonal { /* Add other variants if needed */
  color: var(--color-on-surface-variant); /* Neutral default icon color */
}

/* Override hover/focus for standard outlined iconOnly button */
/* (Does not apply if .colorError, .colorSecondary etc. is also applied) */
.iconOnly.outlined:not([class*='color']):hover,
.iconOnly.outlined:not([class*='color']):focus-visible {
  color: var(--color-secondary); /* Edit icon hover/focus */
  border-color: var(--color-secondary); /* Match border */
}
.iconOnly.outlined:not([class*='color']) > .stateLayer {
  background-color: var(--color-secondary); /* Use secondary for state layer too */
}

/* Ensure error color still applies correctly for iconOnly text buttons */
.iconOnly.text.colorError {
  color: var(--color-error); /* Error color for delete */
}
.iconOnly.text.colorError > .stateLayer {
  background-color: var(--color-error);
}

/* Reset color for variants that use background color as primary indicator */
.iconOnly.filled {
    /* Keep default filled behavior (color determined by .colorPrimary etc) */
    /* This override section is primarily for text/outlined/elevated */
}

/* Visually hide text but keep for screen readers */
.visuallyHidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
  white-space: nowrap;
}

/* === Variant Styles === */

/* --- Filled --- */
.filled {
  /* Colors are set by .color* classes */
}

/* --- Tonal --- */
.tonal {
  /* Colors are set by .color* classes */
}

/* --- Outlined --- */
.outlined {
  background-color: transparent;
  border-width: 1px;
  border-style: solid;
  /* Border color set by .color* classes or defaults */
  /* Text color set by .color* classes or defaults (or iconOnly override) */
}
.outlined .stateLayer {
  /* State layer should use text color (which might be overridden by iconOnly rules) */
  background-color: currentColor;
}

/* --- Text --- */
.text {
  background-color: transparent;
  padding: 0 12px; /* Less padding for text buttons */
  /* Text color set by .color* classes or defaults (or iconOnly override) */
}
.text.iconOnly {
    padding: 0; /* Override text button padding for icon only */
}
.text .stateLayer {
  /* State layer should use text color */
  background-color: currentColor;
}

/* --- Elevated --- */
.elevated {
  /* Uses surface color, shadow added */
  box-shadow: var(--m3-elevation-light-1, 0 1px 2px rgba(0,0,0,0.3)); /* Add M3 elevation vars if defined, fallback */
  /* Background/text colors set by .color* classes */
}
.elevated:hover {
   box-shadow: var(--m3-elevation-light-2, 0 2px 4px rgba(0,0,0,0.3));
}
.elevated:focus-visible {
   box-shadow: var(--m3-elevation-light-2, 0 2px 4px rgba(0,0,0,0.3));
}
.elevated:active {
   box-shadow: var(--m3-elevation-light-1, 0 1px 2px rgba(0,0,0,0.3));
}
html[data-theme='dark'] .elevated {
  box-shadow: var(--m3-elevation-dark-1, 0 1px 2px rgba(0,0,0,0.6));
}
html[data-theme='dark'] .elevated:hover {
   box-shadow: var(--m3-elevation-dark-2, 0 2px 4px rgba(0,0,0,0.6));
}
html[data-theme='dark'] .elevated:focus-visible {
   box-shadow: var(--m3-elevation-dark-2, 0 2px 4px rgba(0,0,0,0.6));
}
html[data-theme='dark'] .elevated:active {
   box-shadow: var(--m3-elevation-dark-1, 0 1px 2px rgba(0,0,0,0.6));
}


/* === Color Modifier Styles === */

/* --- Primary --- */
.colorPrimary.filled {
  background-color: var(--color-primary);
  color: var(--color-on-primary);
}
.colorPrimary.filled > .stateLayer {
  background-color: var(--color-on-primary);
}

.colorPrimary.tonal {
  background-color: var(--color-primary-container);
  color: var(--color-on-primary-container);
}
.colorPrimary.tonal > .stateLayer {
  background-color: var(--color-on-primary-container);
}

.colorPrimary.outlined {
  border-color: var(--color-outline); /* Default outline */
  color: var(--color-primary);
}
.colorPrimary.outlined:focus-visible, /* Use primary for focus/hover state */
.colorPrimary.outlined:hover {
    border-color: var(--color-primary);
}
.colorPrimary.outlined > .stateLayer {
    background-color: var(--color-primary);
}

/* Explicitly reset iconOnly outlined primary back to primary if specified */
.colorPrimary.outlined.iconOnly {
    color: var(--color-primary);
}
.colorPrimary.outlined.iconOnly:hover,
.colorPrimary.outlined.iconOnly:focus-visible {
    border-color: var(--color-primary); /* Ensure border matches */
}
.colorPrimary.outlined.iconOnly > .stateLayer {
    background-color: var(--color-primary);
}

.colorPrimary.text {
  color: var(--color-primary);
}
.colorPrimary.text > .stateLayer {
  background-color: var(--color-primary);
}

.colorPrimary.elevated {
  background-color: var(--color-surface-container-low);
  color: var(--color-primary);
}
.colorPrimary.elevated > .stateLayer {
  background-color: var(--color-primary);
}

/* --- Secondary --- */
.colorSecondary.filled {
  background-color: var(--color-secondary);
  color: var(--color-on-secondary);
}
.colorSecondary.filled > .stateLayer {
  background-color: var(--color-on-secondary);
}

.colorSecondary.tonal {
  background-color: var(--color-secondary-container);
  color: var(--color-on-secondary-container);
}
.colorSecondary.tonal > .stateLayer {
  background-color: var(--color-on-secondary-container);
}

.colorSecondary.outlined {
  border-color: var(--color-outline);
  color: var(--color-secondary);
}
.colorSecondary.outlined:focus-visible,
.colorSecondary.outlined:hover {
    border-color: var(--color-secondary);
}
.colorSecondary.outlined > .stateLayer {
    background-color: var(--color-secondary);
}

/* Explicitly reset iconOnly outlined secondary back to secondary if specified */
.colorSecondary.outlined.iconOnly {
    color: var(--color-secondary);
}
.colorSecondary.outlined.iconOnly:hover,
.colorSecondary.outlined.iconOnly:focus-visible {
    border-color: var(--color-secondary); /* Ensure border matches */
}
.colorSecondary.outlined.iconOnly > .stateLayer {
    background-color: var(--color-secondary);
}

.colorSecondary.text {
  color: var(--color-secondary);
}
.colorSecondary.text > .stateLayer {
  background-color: var(--color-secondary);
}

.colorSecondary.elevated {
  background-color: var(--color-surface-container-low);
  color: var(--color-secondary);
}
.colorSecondary.elevated > .stateLayer {
  background-color: var(--color-secondary);
}

/* --- Tertiary --- */
.colorTertiary.filled {
  background-color: var(--color-tertiary);
  color: var(--color-on-tertiary);
}
.colorTertiary.filled > .stateLayer {
  background-color: var(--color-on-tertiary);
}

/* Tonal Tertiary not explicitly defined in initial M3 set, using secondary-container as placeholder */
.colorTertiary.tonal {
  background-color: var(--color-secondary-container); /* Placeholder */
  color: var(--color-on-secondary-container); /* Placeholder */
}
.colorTertiary.tonal > .stateLayer {
  background-color: var(--color-on-secondary-container); /* Placeholder */
}

.colorTertiary.outlined {
  border-color: var(--color-outline);
  color: var(--color-tertiary);
}
.colorTertiary.outlined:focus-visible,
.colorTertiary.outlined:hover {
    border-color: var(--color-tertiary);
}
.colorTertiary.outlined > .stateLayer {
    background-color: var(--color-tertiary);
}

.colorTertiary.text {
  color: var(--color-tertiary);
}
.colorTertiary.text > .stateLayer {
  background-color: var(--color-tertiary);
}

.colorTertiary.elevated {
  background-color: var(--color-surface-container-low);
  color: var(--color-tertiary);
}
.colorTertiary.elevated > .stateLayer {
  background-color: var(--color-tertiary);
}

/* --- Error --- */
.colorError.filled {
  background-color: var(--color-error);
  color: var(--color-on-error);
}
.colorError.filled > .stateLayer {
  background-color: var(--color-on-error);
}

/* Tonal Error not explicitly defined in initial M3 set, using primary-container as placeholder */
.colorError.tonal {
  background-color: var(--color-primary-container); /* Placeholder: Needs error-container */
  color: var(--color-on-primary-container); /* Placeholder: Needs on-error-container */
}
.colorError.tonal > .stateLayer {
  background-color: var(--color-on-primary-container); /* Placeholder */
}

.colorError.outlined {
  border-color: var(--color-outline);
  color: var(--color-error);
}
.colorError.outlined:focus-visible,
.colorError.outlined:hover {
    border-color: var(--color-error);
}
.colorError.outlined > .stateLayer {
    background-color: var(--color-error);
}

/* Explicitly reset iconOnly outlined error back to error if specified */
.colorError.outlined.iconOnly {
    color: var(--color-error);
}
.colorError.outlined.iconOnly:hover,
.colorError.outlined.iconOnly:focus-visible {
    border-color: var(--color-error); /* Ensure border matches */
}
.colorError.outlined.iconOnly > .stateLayer {
    background-color: var(--color-error);
}

.colorError.text {
  color: var(--color-error);
}
.colorError.text > .stateLayer {
  background-color: var(--color-error);
}

.colorError.elevated {
  background-color: var(--color-surface-container-low);
  color: var(--color-error);
}
.colorError.elevated > .stateLayer {
  background-color: var(--color-error);
}

/* === Disabled State === */
.button:disabled {
  cursor: not-allowed;
  box-shadow: none; /* Remove elevation on disabled */
  /* Text color */
  color: color-mix(in srgb, var(--color-on-surface) 38%, transparent);
}

/* Disabled Background/Border */
.button:disabled,
.filled:disabled,
.tonal:disabled,
.elevated:disabled {
  background-color: color-mix(in srgb, var(--color-on-surface) 12%, transparent);
  border-color: transparent;
}

.outlined:disabled {
  background-color: transparent;
  border-color: color-mix(in srgb, var(--color-on-surface) 12%, transparent);
}

.text:disabled {
  background-color: transparent;
  border-color: transparent;
}

/* Disabled state layer (no interaction) */
.button:disabled > .stateLayer {
  opacity: 0;
} 